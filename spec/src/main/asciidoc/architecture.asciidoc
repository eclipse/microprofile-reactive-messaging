//
// Copyright (c) 2018-2019 Contributors to the Eclipse Foundation
//
// See the NOTICE file(s) distributed with this work for additional
// information regarding copyright ownership.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

[[reactivemessagingarchitecture]]
== Architecture

The Reactive Messaging specification defines a development model for declaring CDI _beans_ producing, consuming and processing messages. 
The communication between these components uses Reactive Streams. 

This specification relies on https://github.com/eclipse/microprofile-reactive-streams-operators[Eclipse MicroProfile Reactive Streams Operators] and http://cdi-spec.org/[CDI].

=== Concepts

This section describes the different concepts introduced by the Reactive Messaging specification

==== Overall architecture

An application using Reactive Messaging is composed of CDI beans consuming, producing and processing _messages_.

These messages can be wholly _internal_ to the application or can be sent and received via different message brokers.

image::overall.png[Overall architecture]

Application's beans contain methods annotated with `@Incoming` and `@Outgoing` annotations. 
A method with an `@Incoming` annotation consumes messages from a _channel_. 
A method with an `@Outgoing` annotation publishes messages to a _channel_.
A method with both an `@Incoming` and an `@Outgoing` annotation is a message processor, it consumes messages from a _channel_, does some transformation to them, and publishes messages to another _channel_.

==== Channel

A _channel_ is a name indicating which source or destination of messages is used.
Channels are opaque `Strings`.

There are two types of channel:

* Internal channels are local to the application. 
They allows implementing multi-step processing where several _beans_ from the same application form a chain of processing.
* Channels can be _connected_ to remote brokers or various message transport layers such as Apache Kafka or to an AMQP broker.
These channels are managed by _connectors_.

==== Message

At the core of the Reactive Messaging specification is the concept of _message_. 
A _message_  is an envelope wrapping a _payload_.
A message is sent to a specific channel and, when received and processed successfully, _acknowledged_.

Reactive Messaging application components are addressable recipients which await the arrival of messages on a channel and react to them, otherwise lying dormant. 

Messages are represented by the `org.eclipse.microprofile.reactive.messaging.Message` class. 
This interface is intentionally kept minimal. The aim is that _connectors_ will provide their own implementations with additional metadata that is relevant to that connector.
For instance, a `KafkaMessage` would provide access to the _topic_ and _partition_.

The `org.eclipse.microprofile.reactive.messaging.Message#getPayload` method retrieves the wrapped payload. 
The `org.eclipse.microprofile.reactive.messaging.Message#ack` method acknowledges the message.
Note that the `ack` method is asynchronous as acknowledgement is generally an asynchronous process.

_Plain_ messages are created using:

* `org.eclipse.microprofile.reactive.messaging.Message#of(T)` - wraps the given payload, no acknowledgement
* `org.eclipse.microprofile.reactive.messaging.Message#of(T, java.util.function.Supplier<java.util.concurrent.CompletionStage<java.lang.Void>>)` - wraps the given payload and provides the acknowledgment logic

==== Message consumption with @Incoming

The `org.eclipse.microprofile.reactive.messaging.Incoming` annotation is used on a method from a CDI bean to indicate that the method consumes messages from the specified channel:

[source,java]
----
@Incoming("my-channel")                                                // <1>
public CompletionStage<Void> consume(Message<String> message) {        // <2>
  return message.ack();
}
----
1. `my-channel` is the channel
2. the method is called for every message sent to the `my-channel` channel

Reactive Messaging supports various forms of method signatures.
This is detailed in the next section.

Remember that Reactive Messaging interactions are assembled from Reactive Streams.
A method annotated with `@Incoming` is a Reactive Streams _subscriber_ and so consumes messages that fit with the message signature and its annotations.
Note that the handling of the Reactive Streams protocol, such as subscriptions and back pressure, is managed by the Reactive Messaging implementation.
The MicroProfile Reactive Streams specification used as a foundation for this version of Reactive Messaging is a single subscriber model where a stream
`Publisher` is connected to a single `Subscriber` which controls back pressure. This implies that a Reactive Messaging channel
should appear in a single `@Incoming` annotation. The annotation of more than one `@Incoming` method to be associated with the
same channel is not supported and will cause an error during deployment.

From the user perspective, whether the incoming messages comes from co-located beans or a remote message broker is transparent.
However, the user may decide to consume a specific subclass of `Message` (e.g. `KafkaMessage` in the following example) if the user is aware of this characteristic:

[source,java]
----
@Incoming("my-kafka-topic")               
public CompletionStage<Void> consume(KafkaMessage<String> message) {    // <1>
  return message.ack();
}
----
1. Explicit consumption of a `KafkaMessage`

==== Message production with @Outgoing

The `org.eclipse.microprofile.reactive.messaging.Outgoing` annotation is used to annotate a method from a CDI bean to indicate that the method publishes messages to a specified channel:

[source,java]
----
@Outgoing("my-channel")                                        // <1>
public Message<String> publish() {                             // <2>
  return Message.of("hello");                                  // <3>
}
----
1. `my-channel` is the targeted channel
2. the method is called for every consumer _request_
3. you can create a _plain_ `org.eclipse.microprofile.reactive.messaging.Message` using `org.eclipse.microprofile.reactive.messaging.Message#of(T)`

Reactive Messaging supports various forms of method signatures.
This is detailed in the next section.

A method annotated with `@Outgoing` is a Reactive Streams _publisher_ and so publishes messages according to the requests it receives.
The downstream `@Incoming` method or outgoing connector with a matching channel name will be linked to this publisher. Only a single method can
be annotated with `@Outgoing` for a particular channel name. Having the same channel name in more than one `@Outgoing` annotated method is not
supported and will result in an error during deployment. 

===== Method consuming and producing

A method can combine the `@Incoming` and `@Outgoing` annotation and will then act as a Reactive Streams processor:

[source,java]
----
@Incoming("my-incoming-channel")                            // <1>
@Outgoing("my-outgoing-channel")                            // <2>
public Message<String> process(Message<String> message) { 
  return Message.of(message.getPayload().toUpperCase());
}
----
1. The incoming channel
2. The outgoing channel

Having the same channel appear in the `@Outgoing` and `@Incoming` annotations of a processor is not supported and will result in an error during deployment.

==== Connectors

The application can receive and forward messages from various message brokers or transport layers.
For instance, an application can be connected to a Kafka cluster, an AMQP broker or an MQTT server.

Reactive Messaging _Connectors_ are extensions managing the communication with a specific transport technology.
They are responsible for mapping a specific _channel_ to remote sink or source of messages.
This mapping is configured in the application configuration.
Note that an implementation may provide various ways to configure the mapping, but support for MicroProfile Config as a configuration source is mandatory.

Connector implementations are associated with a name corresponding to a messaging transport, such as Apache Kafka, Amazon Kinesis, RabbitMQ or Apache ActiveMQ.
For instance, an hypothetical Kafka connector could be associated with the following name: `acme.kafka`.
This name is indicated using a qualifier on the connector implementation.

The user can associate a channel with this connector using the associated name:

[source, properties]
----
mp.messaging.incoming.my-kafka-topic.connector=acme.kafka  # <1>
----
1. the name associated with the connector.

The configuration format is detailed later in this document.

The Reactive Messaging implementation is responsible for finding the connector implementation associated with the given name in the user configuration.
If the connector cannot be found, the deployment of the application must be failed.

The Reactive Messaging specification provides an SPI to implement connectors.

=== Message stream operation

Message stream operation occurs according to the principles of reactive programming.
The back pressure mechanism of reactive streams means that a publisher will not send data to a subscriber unless there are outstanding subscriber requests.
This implies that data flow along the stream is enabled by the first request for data received by the publisher.
For methods that are annotated with `@Incoming` and `@Outgoing` this data flow control is handled automatically by the underlying system which will call the `@Incoming` and `@Outgoing` methods as appropriate.

NOTE: Although `@Incoming` and `@Outgoing` methods remain callable from Java code, calling them directly will not affect the reactive streams they are associated with.
For example, calling an `@Outgoing` annotated method from user code will not post a message on a message queue and calling an `@Incoming` method cannot be used to read a message.
Enabling this would bypass the automatic back pressure mechanism that is one of the benefits of the specification.
The `@Incoming` and `@Outgoing` method annotations are used to declaratively define the stream which is then run by the implementation of MicroProfile Reactive Messaging without the user's code needing to handle concerns such as subscriptions or flow control within the stream.

=== Supported CDI scopes

Implementations of the Reactive Messaging specification must support at least the following CDI scopes:

* `@ApplicationScoped` beans
* `@Dependent` beans

The following code gives an example of a bean annotated with `@ApplicationScoped`:

[source,java]
----
@ApplicationScoped
public class ApplicationScopeBeans {

  @Outgoing("source")
  public Publisher<Integer> source() {
    return ReactiveStreams.of(id).buildRs();
  }

  @Incoming("source")
  @Outgoing("output")
  public int process(int i) {
    return i + 1;
  }

  @Incoming("output")
  public void sink(int v) {
    System.out.println(v);
  }
}
----

Implementations can provide support for other scopes. 
However the behavior is not defined.

=== Supported method signatures

The signature of message stream methods can have a number of different distinct types, offering differing levels of power and simplicity to application developers. Different shapes are supported depending on whether the method is a publisher, subscriber or processor, for example, a publishing stream supports returning MicroProfile Reactive Streams `PublisherBuilder`, but not `SubscriberBuilder`, the inverse is true for a subscribing stream.

This section lists the methods signatures that must be supported by the Reactive Messaging implementation.
Implementations must validate that the stream shape matches the `@Outgoing` and `@Incoming` annotations, if they don't, a CDI definition exception should be raised to the CDI container during initialization.

It's important to remember that users must not call these methods directly. 
They are invoked by the Reactive Messaging implementation following the Reactive Streams protocol.

Also the method must be implemented in a non-blocking fashion.
For blocking transformations, asynchronous variants can be used.

NOTE: _assembly_ time is when the Reactive Messaging implementation initializes itself and creates the different bean instances and connects them together.

NOTE: In the following lists, `Message` can be an implementation of the `Message` interface.

==== Methods producing data

[cols="2a,1,1",options="header"]
|===
|Signature
|Behavior
|Invocation

|
[source, java]
----
@Outgoing("name") 
Publisher<Message<O>> method()
----
| Returns a stream of `Message` associated with the channel `name`. 
| Method called once at assembly time.

|
[source, java]
----
@Outgoing("channel") 
Publisher<O> method()
----
| Returns a stream of _payload_ of type `O` associated with the channel `channel`. Produced payloads are mapped to `Message<O>` by the Reactive Messaging implementation.
| Method called once at assembly time.

|
[source, java]
----
@Outgoing("channel") 
PublisherBuilder<Message<O>> method()
----
| Returns a stream of `Message` associated with the channel `channel`. 
| Method called once at assembly time.

|
[source, java]
----
@Outgoing("channel") 
PublisherBuilder<O> method()
----
| Returns a stream of _payload_ associated with the channel `channel`. Produced payloads are mapped to `Message<O>` by the Reactive Messaging implementation.
| Method called once at subscription time.

|
[source, java]
----
@Outgoing("channel") 
Message<O> method()
----
| Produces an infinite stream of `Message` associated with the channel `channel`. 
|	This method is called for each _request_ made by the subscriber.

|
[source, java]
----
@Outgoing("channel")
O method()
----
| Produces an infinite stream of _payload_ associated with the channel `channel`. Produced payloads are mapped to `Message<O>` by the Reactive Messaging implementation.
|	This method is called for each _request_ made by the subscriber.

|
[source, java]
----
@Outgoing("channel")
CompletionStage<Message<O>> method()
----
| Produces an infinite stream of `Message` associated with the channel `channel`. The result is a `CompletionStage`. The method should not be called by the reactive messaging implementation until the `CompletionStage` returned previously is completed.
|	This method is called for each _request_ made by the subscriber.

|
[source, java]
----
@Outgoing("channel") 
CompletionStage<O> method()
----
| Produces an infinite stream of _payload_ associated with the channel `channel`. Produced payloads are mapped to `Message<O>` by the Reactive Messaging implementation. The result is a `CompletionStage`. The method should not be called by the reactive messaging implementation until the `CompletionStage` returned previously is completed.
|	This method is called for each _request_ made by the subscriber.

|===


==== Methods consuming data

[cols="2a,1,1",options="header"]
|===
|Signature
|Behavior
|Invocation

|
[source,java]
----
@Incoming("channel")
Subscriber<Message<I>> method()
----
| Returns a `Subscriber` that receives the `Message` objects transiting on the channel `channel`.
| The method is called only once to retrieve the `Subscriber` object at assembly time.
 This subscriber is connected to the matching channel.

|
[source,java]
----
@Incoming("channel")
Subscriber<I> method()
----
| Returns a `Subscriber` that receives the _payload_ objects transiting on the channel `channel`.
The payload is automatically extracted from the inflight messages using `Message.getPayload()`.
| The method is called only once to retrieve the `Subscriber` object at assembly time.
 This subscriber is connected to the matching channel.

|
[source,java]
----
@Incoming("channel") 
SubscriberBuilder<Message<I>, Void> method()
----
| Returns a `SubscriberBuilder` that receives the `Message` objects transiting on the channel `channel`.
| The method is called only once at assembly time to retrieve a `SubscriberBuilder` that is used to build a `CompletionSubscriber` that is subscribed to the matching channel. 

|
[source,java]
----
@Incoming("channel")
SubscriberBuilder<I, Void> method()
----
| Returns a `SubscriberBuilder` that is used to build a `CompletionSubscriber<I>`` that receives the _payload_ of each `Message`.
The payload is automatically extracted from the inflight messages using `Message.getPayload()`.
| The method is called only once at assembly time to retrieve a `SubscriberBuilder` that is used to build a `CompletionSubscriber` that is subscribed to the matching channel. 

|
[source,java]
----
@Incoming("channel")
void method(I payload)
----
| Consumes the _payload_.
| This method is called for every `Message<I>` instance transiting on the channel `channel`. 
The payload is automatically extracted from the inflight messages using `Message.getPayload()`.
The user method is never called concurrently and so must return before being called with the next payload.

|
[source,java]
----
@Incoming("channel")
CompletionStage<Void> method(Message<I> msg)
----
| Consumes the `Message` 
| This method is called for every `Message<I>` instance transiting on the channel `channel`. 
The user method is never called concurrently. The reactive messaging implementation must wait until the completion of the previously returned `CompletionStage` before calling the method again with the next `Message`.
Note that `@Incoming("channel") void method(Message<I> msg)` is not allowed as message acknowledgement is asynchronous.

|
[source,java]
----
@Incoming("channel") 
CompletionStage<?> method(I payload)
----
| Consumes the _payload_ asynchronously
| This method is called for every `Message<I>` instance transiting on the channel `channel`. 
The payload is automatically extracted from the inflight messages using `Message.getPayload()`.
The user method is never called concurrently. The reactive messaging implementation must wait until the completion of the previously returned `CompletionStage` before calling the method again with the next _payload_.

|===
	
==== Methods processing data

[cols="2a,1,1",options="header"]
|===
|Signature
|Behavior
|Invocation

| 
[source,java]
----
@Incoming("in")
@Outgoing("out")
Processor<Message<I>, Message<O>> method()
----
| Returns a Reactive Streams processor consuming incoming `Message` instances and produces `Message` instances.
| This method is called once; at assembly time.

| 
[source,java]
----
@Incoming("in")
@Outgoing("out") 
Processor<I, O> method();
----
| Returns a Reactive Streams processor consuming incoming _payload_ instances and produces _payload_ instances.
| This method is called once; at assembly time.

|
[source,java]
----
@Incoming("in")
@Outgoing("out") 
ProcessorBuilder<Message<I>, Message<O>> method();
----
| Returns a `ProcessorBuilder` consuming incoming `Message` instances and produces `Message` instances.
| This method is called once; at assembly time.

|
[source,java]
----
@Incoming("in")
@Outgoing("out") 
ProcessorBuilder<I, O> method();
----
| Returns a Reactive Streams processor that consuming incoming _payload_ instances and produces _payload_ instances.
| This method is called once; at assembly time.

|
[source,java]
----
@Incoming("in")
@Outgoing("out") 
Publisher<Message<O>> method(Message<I> msg)
----
| Returns a Reactive Streams `Publisher` for each incoming `Message`.
The returned `Publisher` can be empty or emits multiple `Message` instances.
If the returned `Publisher` emits several elements, these elements are _flattened_ in the outgoing stream as a concatenation of elements.
The _flattening_ follows the same semantics as the `flatMap` operator from the MicroProfile Reactive Streams specification.
| This method is called for every incoming message. Implementations must not call the method subsequently until the stream from the previously returned `Publisher` is completed.

|
[source,java]
----
@Incoming("in")
@Outgoing("out") 
Publisher<O> method(I payload)
----
| Returns a Reactive Streams `Publisher` for each incoming _payload_.
The returned `Publisher` can be empty or emits multiple _payload_ instances.
If the returned `Publisher` emits several elements, these elements are _flattened_ in the outgoing stream as a concatenation of elements.
The _flattening_ follows the same semantics as the `flatMap` operator from the MicroProfile Reactive Streams specification.
The Reactive Messaging implementation must create new `Message` instances for each emitted _payload_ as well as extracing the payload for each incoming `Message`.
| This method is called for every incoming message. Implementations must not call the method subsequently until the stream from the previously returned `Publisher` is completed.

|
[source,java]
----
@Incoming("in")
@Outgoing("out") 
PublisherBuilder<Message<O>> method(Message<I> msg)
----
| Returns a `PublisherBuilder` for each incoming `Message`.
The stream resulting from the built `Publisher` can be empty or emits multiple `Message` instances.
If the stream emitted from the built `Publisher` emits several elements, these elements are _flattened_ in the outgoing stream as a concatenation of elements.
The _flattening_ follows the same semantics as the `flatMap` operator from the MicroProfile Reactive Streams specification.
| This method is called for every incoming message. Implementations must not call the method subsequently until the stream built from the previously returned `PublisherBuilder` is completed.

|
[source,java]
----
@Incoming("in")
@Outgoing("out") 
PublisherBuilder<O> method(I payload)
----
| Returns a `PublisherBuilder` for each incoming _payload_.
The stream resulting from the built `Publisher` can be can be empty or emits multiple _payload_ instances.
If the stream emitted from the built `Publisher` emits several elements, these elements are _flattened_ in the outgoing stream as a concatenation of elements.
The _flattening_ follows the same semantics as the `flatMap` operator from the MicroProfile Reactive Streams specification.
The Reactive Messaging implementation must create new `Message` instances for each emitted _payload_ as well as extracing the payload for each incoming `Message`.
| This method is called for every incoming message. Implementations must not call the method subsequently until the stream built from the previously returned `PublisherBuilder` is completed.


|
[source,java]
----
@Incoming("in")
@Outgoing("out") 
Message<O> method(Message<I> msg)
----
| Returns a `Message` for each incoming `Message`.
| This method is called for every incoming message. Implementations must not call the method subsequently until the previous call must have returned.

|
[source,java]
----
@Incoming("in")
@Outgoing("out") 
O method(I payload)
----
| Returns a _payload_ for each incoming _payload.
The Reactive Messaging implementation is responsible for unwrapping the _payload_ from the incoming `Message` and creating a `Message` from the returned _payload_.
| This method is called for every incoming message. Implementations must not call the method subsequently until the previous call must have returned.

|
[source,java]
----
@Incoming("in")
@Outgoing("out") 
CompletionStage<Message<O>> method(Message<I> msg)
----
| Produces a `Message` for each incoming `Message`. This method returns a `CompletionStage` that can redeem the `Message` instance asynchronously. The returned `CompletionStage` must not be completed with `null`.
| This method is called for every incoming message. Never concurrently. The implementations must wait until the completion of the previously returned `CompletionStage` before calling the method again with the next `Message`.
|
[source,java]
----
@Incoming("in")
@Outgoing("out") 
CompletionStage<O> method(I payload)
----
| Produces a _payload_ for each incoming _payload_. This method returns a `CompletionStage` that can redeem the _payload_ instance asynchronously. The returned `CompletionStage` must not be completed with `null`.
| This method is called for every incoming _payload_. Never concurrently. The implementations must wait until the completion of the previously returned `CompletionStage` before calling the method again with the next _payload_.

|
[source,java]
----
@Incoming("in")
@Outgoing("out") 
Publisher<Message<O>> method(Publisher<Message<I>> pub)
----
| Applies a transformation to the incoming stream of `Message`. This method is used to manipulate streams and apply stream transformations.
| This method is called once, at _assembly_ time.

|
[source,java]
----
@Incoming("in")
@Outgoing("out") 
PublisherBuilder<Message<O>> method(PublisherBuilder<Message<I>> pub)
----
| Applies a transformation to the stream represented by the `PublisherBuilder` of `Message`. This method is used to manipulate streams and apply stream transformations.
| This method is called once, at _assembly_ time.

|
[source,java]
----
@Incoming("in")
@Outgoing("out") 
Publisher<O> method(Publisher<I> pub)
----
| Applies a transformation to the incoming streams of _payloads_.  This method is used to manipulate streams and apply stream transformations.
| This method is called once, at _assembly_ time.

|
[source,java]
----
@Incoming("in")
@Outgoing("out") 
PublisherBuilder<O> method(PublisherBuilder<I> pub)
----
| Applies a transformation to the stream represented by the `PublisherBuilder` of _payloads_. This method is used to manipulate streams and apply stream transformations.
| This method is called once, at _assembly_ time.

|===

==== Examples of simple method streams

The simplest shape that an application may use is a simple method. This is a method that accepts an incoming message, and possibly publishes an outgoing message:

[source, java]
----
@Incoming("in")
@Outgoing("out")
public Message<O> process(Message<I> msg) {
  return convert(msg);
}
----

In the above example, the stream is both a publishing and subscribing stream, with a 1:1 mapping of incoming to outgoing messages. 
Asynchronous processing may also be used, by returning a `CompletionStage`:

[source, java]
----
@Incoming("in")
@Outgoing("out")
public CompletionStage<Message<O>> process(Message<I> msg) {
  return asyncConvert(msg);
}
----

If the method is not `@Outgoing` annotated, then the returned value is ignored - however, note that for asynchronous methods, the returned `CompletionStage` is still important for determining when message processing has completed successfully, for the purposes of message acknowledgement. 
When there is no `@Outgoing` annotation, `void` may also be returned.

In addition to `Message`, implementations must allow:

* payloads (the content wrapped in a `Message`)
* implementation of the `Message` interface

==== Examples of methods using Reactive Streams or MicroProfile Reactive Streams Operators types

For more power, developers may use Reactive Streams instances. Reactive Streams shaped methods accept no parameters, and return one of the following:

* `org.eclipse.microprofile.reactive.streams.operators.PublisherBuilder`
* `org.eclipse.microprofile.reactive.streams.operators.SubscriberBuilder`
* `org.eclipse.microprofile.reactive.streams.operators.ProcessorBuilder`
* `org.reactivestreams.Publisher`
* `org.reactivestreams.Subscriber`
* `org.reactivestreams.Processor`

Implementations may optionally support other types, such as JDK9 Flow publishers, subscribers and processors, or other representations of Reactive Streams. 
Application developers are recommended to use the MicroProfile Reactive Streams Operators _builders_ in order to allow for the highest level of portability.

For example, here's a message processor:

[source, java]
----
@Incoming("in")
@Outgoing("out")
public PublisherBuilder<Message<I>, Message<O>> process() {
  return ReactiveStreams.<Message<I>>builder()
    .map(this::convert);
}
----

NOTE: Implementations must support implementations of the `Message` interface.

=== Message acknowledgement

Acknowledgement is an important part of message processing.
Messages are either acknowledged explicitly, or implicitly by the implementation.
All messages must be acknowledged.

Acknowledgement for the `@Incoming` messages is controlled by the `org.eclipse.microprofile.reactive.messaging.Acknowledgment` annotation. 
The annotation allows configuring the acknowledgement strategy among:

* `MANUAL` - the user is responsible for the acknowledgement, by calling the `Message#ack()` method, so the Reactive Messaging implementation does not apply implicit acknowledgement
* `PRE_PROCESSING` - the Reactive Messaging implementation acknowledges the message before the annotated method or processing is executed
* `POST_PROCESSING` - the Reactive Messaging implementation acknowledges the message once:

  1. the method or processing completes if the method does not emit data
  2. when the emitted data is acknowledged

Each method signature type has different defaults and can implement different acknowledgement policies.
If the `Acknowledgment` annotation is not set, the default policy is applied.

IMPORTANT: Method only annotated with `@Outgoing` do not support acknowledgement as they don't receive an input `Message`.

When a method annotated with `@Incoming` defines its acknowledgement policy to be `PRE_PROCESSING` or `POST_PROCESSING`, the Reactive Messaging implementation is responsible for the acknowledgement of the message.
When the `POST_PROCESSING` policy is used, the incoming message is acknowledged when the outgoing message is acknowledged.
Thus, it creates a chain of acknowledgements, making sure that the messages produced by an `IncomingConnectorFactory` are only acknowledged when the dispatching of the messages has been completed successfully.

The `MANUAL` strategy indicates that the incoming message acknowledgement is managed by the user code.
The `MANUAL` strategy is often used to acknowledge incoming messages when the produced messages are acknowledged.
For example, in the next snippet, the received `KafkaMessage` is acknowledged when the produced message is acknowledged.

[source, java]
----
@Incoming("data")
@Outgoing("sink")
@Acknowledgment(Acknowledgment.Strategy.MANUAL)
public Message<Integer> process(KafkaMessage<String, Integer> input) {
  return Message.of(processThePayload(input.getPayload(), () -> input.ack());
}
----

Specifying `NONE` as acknowledgment strategy allows for this method to complete processing and return without handling
 acknowledgment and for this to be considered valid behavior of the method.
However, if messages were never acknowledged this would result in a build-up of unacknowledged messages in the system as
 no automatic acknowledgment will be done when `NONE` is specified.
When 'NONE' is specified, each message object's `ack()` method should still be invoked once as part of the overall
processing but this is considered valid behavior either before, during, or after this method's execution.


The following table indicates the defaults and supported acknowledgement for each supported signature:

[cols="2a,1,1",options="header"]
|===
|Signature
|Default Acknowledgement Strategy
|Supported Strategies

|
[source,java]
----
@Incoming("channel")
Subscriber<Message<I>> method()
----
| Post-Processing	
| None, Pre-Processing, Post-Processing (when the `onNext` method returns), Manual

|
[source,java]
----
@Incoming("channel")
Subscriber<I> method()
----
| Post-Processing	
| None, Pre-Processing, Post-Processing (when the `onNext` method returns)

|
[source,java]
----
@Incoming("channel") 
SubscriberBuilder<Message<I>, Void> method()
----
| Post-Processing	
| None, Pre-Processing, Post-Processing (when the `onNext` method returns), Manual


|
[source,java]
----
@Incoming("channel")
SubscriberBuilder<I, Void> method()
----
| Post-Processing	
| None, Pre-Processing, Post-Processing (when the `onNext` method returns)

|
[source,java]
----
@Incoming("channel")
void method(I payload)
----
| Post-Processing	
| None, Pre-Processing, Post-Processing (when the method returns)

|
[source,java]
----
@Incoming("channel")
CompletionStage<?> method(Message<I> msg)
----
| Post-Processing
| None, Pre-Processing, Post-Processing (when the returned `CompletionStage` is completed), Manual

|
[source,java]
----
@Incoming("channel") 
CompletionStage<?> method(I payload)
----
| Post-Processing	
| None, Pre-Processing, Post-Processing (when the returned `CompletionStage` is completed)

| 
[source,java]
----
@Incoming("in")
@Outgoing("out")
Processor<Message<I>, Message<O>> method()
----
| Pre-Processing
| None, Pre-Processing, Manual

| 
[source,java]
----
@Incoming("in")
@Outgoing("out") 
Processor<I, O> method();
----
| Pre-Processing
| None, Pre-Processing
Post-Processing can be optionally supported by implementations, however it requires a 1:1 mapping between the incoming element and the outgoing element.

|
[source,java]
----
@Incoming("in")
@Outgoing("out") 
ProcessorBuilder<Message<I>, Message<O>> method();
----
| Pre-Processing
| None, Pre-Processing, Manual

|
[source,java]
----
@Incoming("in")
@Outgoing("out") 
ProcessorBuilder<I, O> method();
----
| Pre-Processing
| None, Pre-Processing
Post-Processing can be optionally supported by implementations, however it requires a 1:1 mapping the incoming element and the outgoing element.

|
[source,java]
----
@Incoming("in")
@Outgoing("out") 
Publisher<Message<O>> method(Message<I> msg)
----
| Pre-Processing
| None, Manual, Pre-Processing

|
[source,java]
----
@Incoming("in")
@Outgoing("out") 
Publisher<O> method(I payload)
----
| Pre-Processing
| None, Pre-Processing

|
[source,java]
----
@Incoming("in")
@Outgoing("out") 
PublisherBuilder<Message<O>> method(Message<I> msg)
----
| Pre-Processing
| None, Manual, Pre-Processing

|
[source,java]
----
@Incoming("in")
@Outgoing("out") 
PublisherBuilder<O> method(I payload)
----
| Pre-Processing
| None, Pre-Processing


|
[source,java]
----
@Incoming("in")
@Outgoing("out") 
Message<O> method(Message<I> msg)
----
| Pre-Processing
| None, Manual, Pre-Processing

|
[source,java]
----
@Incoming("in")
@Outgoing("out") 
O method(I payload)
----
| Post-Processing
| None, Pre-Processing, Post-Processing (when the message wrapping the produced payload is acknowledged)

|
[source,java]
----
@Incoming("in")
@Outgoing("out") 
CompletionStage<Message<O>> method(Message<I> msg)
----
| Pre-Processing
| None, Manual, Pre-Processing

|
[source,java]
----
@Incoming("in")
@Outgoing("out") 
CompletionStage<O> method(I payload)
----
| Post-Processing
| None, Pre-Processing, Post-Processing (when the message wrapping the produced payload is acknowledged)

|
[source,java]
----
@Incoming("in")
@Outgoing("out") 
Publisher<Message<O>> method(Publisher<Message<I>> pub)
----
| Pre-Processing
| None, Manual, Pre-Processing

|
[source,java]
----
@Incoming("in")
@Outgoing("out") 
PublisherBuilder<Message<O>> method(PublisherBuilder<Message<I>> pub)
----
| Pre-Processing
| None, Manual, Pre-Processing

|
[source,java]
----
@Incoming("in")
@Outgoing("out") 
Publisher<O> method(Publisher<I> pub)
----
| Pre-Processing
| None, Pre-Processing

|
[source,java]
----
@Incoming("in")
@Outgoing("out") 
PublisherBuilder<O> method(PublisherBuilder<I> pub)
----
| Pre-Processing
| None, Pre-Processing

|===

Invalid acknowledgement policies must be detected and a `DeploymentException` raised when the application is deployed.

==== Acknowledgement Examples

Transiting data may be wrapped in a `Message`, which can be used to supply metadata, and also allows messages to be acknowledged. 
The contract for acknowledging messages is anything that accepts a `Message` is required to acknowledge it. 
So, if the application receives an incoming message wrapped in `Message`, it is responsible for invoking `Message.ack()`, and if the application publish an outgoing message wrapped in `Message`, then the spec implementation is responsible for invoking `Message.ack()`.

For example, the following application code is incorrect, since it accepts a message wrapped in `Message`, but does not acknowledge the messages:

[source, java]
----
@Incoming("in")
@Acknowledgment(Acknowledgment.Strategy.MANUAL)
public void process(Message<I> msg) {
  System.out.println("Got message " + msg.getPayload());
}
----

Here is a correct implementation:

[source, java]
----
@Incoming("in")
@Acknowledgment(Acknowledgment.Strategy.MANUAL)
public CompletionStage<Void> process(Message<I> msg) {
  System.out.println("Got message " + msg.getPayload());
  return msg.ack();
}
----

This implementation is also correct, since the application receives a payload wrapped in a message.
It's the implementations responsibility to invoke `ack()` on the incoming message:

[source, java]
----
@Incoming("in")
public void process(I payload) {
  System.out.println("Got payload " + payload);
}
----

When dealing with payloads, the `POST_PROCESSING` strategy is the default strategy.
In the following snippet, the incoming payload is transported into a message and unwrapped before calling the method.
The produced result is wrapped into another `Message`.
Following the `POST_PROCESSING` strategy, the incoming message must only be acknowledged when the output message is acknowledged.
The implementation is responsible to chain the acknowledgements.

[source, java]
----
@Incoming("in")
@Outgoing("out")
public O process(I payload) {
  ...
}
----

The acknowledgment strategy can be changed.
For instance, using the `PRE_PROCESSING` strategy, the incoming message is acknowledged before the method is called.
It also means that the acknowledgment of the outgoing message would not acknowledge the incoming message anymore, as it's already acknowledged.

[source, java]
----
@Incoming("in")
@Outgoing("out")
@Acknowledgment(Acknowledgment.Strategy.PRE_PROCESSING)
public O process(I payload) {
  ...
}
----

The `NONE` strategy indicates that the incoming message is not acknowledged and the acknowledgment of the outgoing message would not acknowledge the incoming message anymore.
The `NONE` strategy may be used when the incoming messages are acknowledged in another location, or a different mechanism..

[source, java]
----
@Incoming("in")
@Outgoing("out")
@Acknowledgment(Acknowledgment.Strategy.NONE)
public O process(I payload) {
  ...
}
----

The `MANUAL` strategy indicates that the acknowledgment is managed by the user code. 
The following snippet is particularly useful for processing messages that are also being sent to a destination, as the implementation must not invoke `ack` until after the outgoing message has been sent to the destination:

[source, java]
----
@Incoming("in")
@Outgoing("out")
@Acknowledgment(Acknowledgment.Strategy.MANUAL)
public Message<O> process(Message<I> msg) {
  return Message.of(convert(msg.getPayload()), msg::ack);
}
----

The implementation is responsible for enforcing the acknowledgement strategy defined by the user when the `@Acknowledgement` policy is used.
If the annotation is not used, the default policy must be enforced.

=== Connector

Reactive Messaging connects matching `@Incoming` and `@Outgoing` stream elements running inside the same application.
Additionally, it maps specific _channels_ to _external_ technologies such as Apache Kafka, MQTT, Web Sockets, AMQP, or JMS.
This means that Reactive Messaging can receive messages from virtually any messaging technology and dispatch messages to any messaging technology.
This bridging to an external messaging technology is done using a reactive messaging _connector_.

==== Connector concepts

Each _connector_ is responsible for a specific technology. 
A connector can:

* act as a _Publisher_, meaning it retrieves or receives messages from an external messaging technology and publishes them to a reactive stream.
 The messages will then be sent to a method annotated with `@Incoming`.
* act as a _Subscriber_, meaning it subscribes to a reactive stream and dispatches messages to an external messaging technology.
The messages are received from a method annotated with `@Outgoing`.
* handle both directions.

It's essential that connectors implement the back-pressure protocol defined by the Reactive Streams specification.

A _connector_ is implemented as a CDI Bean, generally _application_ scoped implementing:

* the `org.eclipse.microprofile.reactive.messaging.connector.IncomingConnectorFactory` interface to receive messages from an external source;
* the `org.eclipse.microprofile.reactive.messaging.connector.OutgoingConnectorFactory` interface to dispatch messages to an external sink

NOTE: Depending on the integrated technology, the _connector_ can implement one of the interface or both.

The bean is a factory called by the Reactive Messaging implementation to create `PublisherBuilder` or `SubscriberBuilder` objects. 
These objects are then connected to methods annotated with `@Incoming` or `@Outgoing`. 

Beans implementing the `IncomingConnectorFactory` or `OutgoingConnectorFactory` must use the `org.eclipse.microprofile.reactive.messaging.spi.Connector` qualifier.
This qualifier defined the name associated with the connector.

The `@Connector` qualifier is used as follows:

[source, java]
----
package org.eclipse.reactive.sample.kafka;

import org.eclipse.microprofile.reactive.messaging.spi.*;

@ApplicationScoped
@Connector("acme.kafka")
public class KafkaConnector implements IncomingConnectorFactory, OutgoingConnectorFactory {
    // ...
}
----

Once defined, the user can, in the configuration, refer to this connector using the given name (`acme.kafka` in this example).
When the Reactive Messaging implementation processes the configuration, it determines the connector to be used based on the `connector` attribute.

==== Configuration

Reactive Messaging connectors are configured using MicroProfile Config.
The implementation processes the global configuration and determines:

* which channels are defined
* which connectors are used (using the `connector`) attribute
* the configuration for each channel

The builder methods defined in the `IncomingConnectorFactory` and `OutgoingConnectorFactory` receive a `org.eclipse.microprofile.config.Config` as parameter.
The `Config` object contains key-value pairs to configure the connector.
The configuration is specific to the connector.
For example, a Kafka connector expects a _bootstrap.servers_ entry as well as a _topic_ entry.

The Reactive Messaging implementation reads the global application configuration and must support the following format:

* `mp.messaging.incoming.[channel-name].[attribute]=[value]`
* `mp.messaging.outgoing.[channel-name].[attribute]=[value]`
* `mp.messaging.connector.[connector-name].[attribute]=[value]`

For each extracted `channel-name`:

1. The `connector` attribute of the channel is read, and the connector implementation identified. If no loadable connector implementation matches, the deployment must be failed with a `DeploymentException`;
2. Relevant attributes are those matching either the `channel-name` or the resolved `connector-name`.
3. Relevant attributes are processed to generate a `Config` object containing only `attribute=value` entries.
If is valid to have an attribute specified at a connector level and also for a specific channel.
If an attribute appears for both a channel and its relevant connector, the channel specific value will be used.
In the example below, the `acme.kafka` default value for `bootstrap.servers` is overridden for `my-channel` to be `9096`.

The following snippet gives an example for a hypothetical Kafka connector:
 
[source]
----
 mp.messaging.incoming.my-channel.connector=acme.kafka
 mp.messaging.incoming.my-channel.bootstrap.servers=localhost:9096
 mp.messaging.incoming.my-channel.topic=my-topic
 mp.messaging.connector.acme.kafka.bootstrap.servers=localhost:9092
---- 

For properties that have a `mp.messaging.incoming.` or `mp.messaging.outgoing` prefix, 
this prefix is stripped off the property name and the remainder of the property name
up to the first occurrence of `.` is treated as the channel name. Channel names may not
include the `.` character.

For properties that have a `mp.messaging.connector.` prefix, this prefix is stripped off the property name and
the longest remaining prefix that matches any configured `connector`
is treated as a connector name. 
The remainder of the property name, minus the expected initial `.` separator,  is taken
as the name of an attribute for this connector. For example `bootstrap.servers` appears as a
default attribute for all channels that use the `acme.kafka` connector. 

The Reactive Messaging implementation:

1. Reads the configuration
2. Identifies that a `my-channel` source needs to be managed
3. Searches for the `connector` attribute and finds `acme.kafka`
4. Looks for a bean implementing the `IncomingConnectorFactory` interface qualified with `@Connector("acme.kafka")`.
If the configuration had contained a `mp.messaging.outgoing.my-channel...` entry, a bean implementing the `OutgoingConnectorFactory` interface would have been searched for.
5. Creates a new `Config` object with just the relevant `key=value` pairs:
+
[source]
----
bootstrap.servers=localhost:9096
topic=my-topic
---- 
+
6. Calls the `PublisherBuilder<? extends Message> getPublisherBuilder(Config config)` method with the created `Config` object. If the configuration is invalid, the connector can throw:
+
* a `NoSuchElementException` if a mandatory attribute is missing in the configuration
* an `IllegalArgumentException` if the initialization of the connector fails for any other reasons.
+
The Reactive Messaging implementation catches these exceptions and wraps them into a `DeploymentException`, failing the deployment of the application.

7. The built `PublisherBuilder` is connected to a method using the `@Incoming("my-stream")` annotation. The implementation of the connector must map every received message to an `org.eclipse.microprofile.reactive.messaging.Message`. Optionally, it can provide its own implementation of `org.eclipse.microprofile.reactive.messaging.Message` providing additional metadata.

The configuration passed to the `IncomingConnectorFactory` and `OutgoingConnectorFactory` contains at least the:

* `channel-name` attribute indicating the name of the channel being configured,
* `connector` attribute indicating the fully qualified name of the connector.

==== Acknowledgement 

The connector is responsible for the acknowledgment of the incoming and outgoing messages:

* An incoming connector must only acknowledge the received message when the produced `org.eclipse.microprofile.reactive.messaging.Message` is acknowledged.
* An outgoing connector must acknowledge the incoming `org.eclipse.microprofile.reactive.messaging.Message` once it has successfully dispatched the message.

== Metrics

When MicroProfile Reactive Metrics is used in an environment where MicroProfile Metrics is enabled, the Reactive Messaging implementation automatically produces metrics.

The following metrics are produced for each channel declared by the application

[cols="8,3,4,9"]
|===
| Name | Type | Unit | Description

| `mp.messaging.message.count{channel="<channelname>"}`
| Counter | None
| The number of messages sent on the named channel.

|===


// ==== Custom message types

// Implementations may provide custom subtypes of `Message` as an end user API, for the purpose of providing additional metadata associated with the messaging provider. If an application declares that it consumes or produces a subtype of the `Message` wrapper, the implementation should validate that the messaging provider supports that message wrapper type, and raise a deployment exception if it doesn't.

== Publishing messages to a stream from imperative code
Traditionally, the reactive world and imperative world are separated and operate in parallel. Reactive Messaging deals with streams of data in the reactive world, while the imperative world is pretty much point to point and synchronous communication. However, imperative programme sometimes needs to connect to reactive streams so that responses can be emitted to a destination service. 
Bridging the two worlds is very valuable thing to do, so that one microservice can use technologies from both environments. For an instance, a JAX-RS resource might want to publish messages to a Reactive Messaging channel. This section is about enabling imperative code to publish messages to a Reactive Messaging channel, so that it can be consumed by a consumer.
The approach is to introduce the concept of _channel_.

=== Connect to a channel

In order to publish messages on a _channel_, we need to connect a channel first. `@Channel("channel_name")` is used for this purpose.
`@Channel` is a qualifier to inject a _channel_ to a CDI bean or any class that supports CDI injection. 

=== Transit messages to a channel

You can either inject a _Publisher_ or _PublisherBuilder_ with the specified channel, shown below.

[source, java]
----

@Inject
@Channel("myChannel")
private Publisher<Message<String>> field;

----

The value _myChannel_ indicates the name of the channel. A channel can be used for the following type:

* Publisher<Message<X>> or Publisher<X>
* PublisherBuilder<Message<X>> or PublisherBuilder<X>


In addition to the above messaging publishers, an additional `Emitter` is also providied by this specification. 

* Emitter<X>


For an instance, in order for a method to send messages, you can use _Emitter_ to send payload `X` or `Message<X>`, as demonstrated below.

[source, java]
----
@Inject @Channel("myChannel")
private Emitter<String> emitter;

public void publishMessage() {
  emitter.send("a");
  emitter.send("b");
  emitter.complete();
}
----

[source, java]
----
@Inject
@Channel("foo")
private Emitter<String> emitter;

public void run() {
    emitter.send(Message.of("a"));
    emitter.send(Message.of("b"));
    emitter.send(Message.of("c"));
}

----

When injecting an _Emitter_ (e.g. `@Inject @Emitter`), you can configure how the backpressure is handled. The `@OnOverflow` annotation configures how the backpressure behaves when emitting messages/payloads faster than the consumption of the messages.

[source, java]
----
@Inject @Channel("myChannel")
@OnOverflow(value=OnOverflow.Strategy.BUFFER, bufferSize=300)
Private Emitter<String> emitter;

public void publishMessage() {
  emitter.send("a");
  emitter.send("b");
  emitter.complete();
}
----

In the above snippet, the buffer size is set to 300 elements. If `_@OnOverflow_` is absent, the buffer strategy _OnOverflow.Strategy.BUFFER_ will be used. 

If the `bufferSize` is not specified, the size will be the value of the config property _mp.messaging.emitter.defult-buffer-size_.
If the property does not exist, the default value will be 128 elements. If the buffer is full, an error will be propagated.

The _value_ attribute on `OnOverflow` can be:

* `OnOverflow.Strategy.BUFFER` - use a buffer, whose size will be determined by the value of _bufferSize_ if set. Otherwise, the size will be the value of the config property _mp.messaging.emitter.defult-buffer-size_ if it exists. Otherwise, 128 will be used. If the buffer is full, an error will be propagated.
* `OnOverflow.Strategy.UNBOUNDED_BUFFER` - use an unbounded buffer. If the buffer is full, the applicaiton will die of _OutOfMemory_.
* `OnOverflow.Strategy.DROP` - drops the most recent value if the downstream cant keep up. It means that new value emitted by the emitter are ignored.
* `OnOverflow.Strategy.FAIL` - propagates a failure in case the downstream cant keep up.
* `OnOverflow.Strategy.LATEST` - keeps only the latest value, dropping any previous value if the downstream cant keep up.
* `OnOverflow.Strategy.NONE` - ignore the back-pressure signals letting the downstream consumer to implement a strategy.

Here are some examples:

[source, java]
----

@Inject
@Channel("myChannel")
@OnOverflow(value = OnOverflow.Strategy.BUFFER) // Buffer strategy using the buffer size specified by _mp.messaging.emitter.defult-buffer-size_ if exists. Otherwise, 128 will be used.
Emitter<String> emitter;

@Inject
@Channel("myChannel") // Buffer strategy will be used. It behaves as if @OnOverflow(value = OnOverflow.Strategy.BUFFER) is present.
Emitter<String> emitter;

@Inject
@Channel("myChannel")
@OnOverflow(value = OnOverflow.Strategy.DROP) // Drop the most recent values
Emitter<String> emitter;
----
    
Since the `@Channel("myChannel")` is used to produce messages, a consumer with the `@Incoming("myChannel")` should be specified to consume the messages transiting on the channel _myChannel_.
The `IllegalStateException` will be thrown if no consumer is found by the time a message is emitted to a channel.

